// %nameParser.h
// LMNO parser generator template
//
// Copyright Â©2010-2011 Brigham Toskin.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// Some portions of the Software are taken from the Public Domain.
// Based on Lemon v1.
//
////////////////////////////////////////////////////////////////////////////////
//
// This file was generated by LMNO for the %name parser.
// All user-supplied content is the property of its respective authors and is
// subject to the following copyright and licensing terms:
%%
////////////////////////////////////////////////////////////////////////////////


#pragma once

#include <iostream>
 using std::ostream;
#include <string>
 using std::string;
#include <deque>
 using std::deque;

// user includes
%%

// Token ID codes
%%

/* The next thing included is series of defines which control
 * various aspects of the generated parser.
 *    YYCODETYPE         is the data type used for storing terminal
 *                       and nonterminal numbers.  "unsigned char" is
 *                       used if there are fewer than 250 terminals
 *                       and nonterminals.  "int" is used otherwise.
 *    YYNOCODE           is a number of type YYCODETYPE which corresponds
 *                       to no legal terminal or nonterminal number.  This
 *                       number is used to fill in empty slots of the hash 
 *                       table.
 *    YYFALLBACK         If defined, this indicates that one or more tokens
 *                       have fall-back values which should be used if the
 *                       original value of the token will not parse.
 *    YYACTIONTYPE       is the data type used for storing terminal
 *                       and nonterminal numbers.  "unsigned char" is
 *                       used if there are fewer than 250 rules and
 *                       states combined.  "int" is used otherwise.
 *    %nameTOKENTYPE     is the data type used for minor tokens given 
 *                       directly to the parser from the tokenizer.
 *    YYMINORTYPE        is the data type used for all minor tokens.
 *                       This is typically a union of many types, one of
 *                       which is %nameTOKENTYPE.  The entry in the union
 *                       for base tokens is called "yy0".
 *    YYSTACKDEPTH       is the maximum depth of the parser's stack.
 *    %nameARG_SDECL     A static variable declaration for the %extra_argument
 *    %nameARG_PDECL     A parameter declaration for the %extra_argument
 *    %nameARG_STORE     Code to store %extra_argument into yypParser
 *    %nameARG_FETCH     Code to extract %extra_argument from yypParser
 *    YYNSTATE           the combined number of states.
 *    YYNRULE            the number of rules in the grammar
 *    YYERRORSYMBOL      is the code number of the error symbol.  If not
 *                       defined, then do no error processing.
 */
%%
#define YY_NO_ACTION      (YYNSTATE+YYNRULE+2)
#define YY_ACCEPT_ACTION  (YYNSTATE+YYNRULE+1)
#define YY_ERROR_ACTION   (YYNSTATE+YYNRULE)

// Stack Entry /////////////////////////////////////////////////////////////////

/*
 * Information stored includes:
 *
 *  +  The state number for the parser at this level of the stack.
 *
 *   +  The numeric value of the token stored at this level of the stack.
 *      (In other words, the "major" token.)
 *
 *   +  The semantic value stored at this level of the stack.  This is
 *      the information used by the action routines in the grammar.
 *      It is sometimes called the "minor" token.
 */
struct yyStackEntry
{
	yyStackEntry() : stateno(0), major(0) { }
	yyStackEntry(int state, int major, YYMINORTYPE minor)
		: stateno(state), major(major), minor(minor) { }

	int stateno;       // parser state
	int major;         // major token value
	YYMINORTYPE minor; // user-supplied minor token value
};

// Shift-Reduce Stack //////////////////////////////////////////////////////////

class yyStack
{
public:
	inline void push(const yyStackEntry& item);
	inline yyStackEntry pop();
	inline void lop();
	inline void lop(size_t count);
	inline yyStackEntry& top();
	
	inline void clear();
	inline size_t size();
	inline bool empty();
	
	inline yyStackEntry& operator[](size_t);
private:
	yyStackEntry popped_val;
	deque<yyStackEntry> c;
};

// Parser //////////////////////////////////////////////////////////////////////

/**
 * This is the main parser class. It implements a LARL(1) Shift-Reduce parser.
 */
class %nameParser
{
public:
	%nameParser() : errCount(0) { stack.push(yyStackEntry()); }
	
	void Parse(int yymajor, %nameTOKENTYPE yyminor %nameARG_PDECL);
	
	void Trace(ostream *traceStream, const string& tracePrompt);
	void Trace();
	const string TokenName(int tokenType);
	
protected:
	void destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor);

	int find_shift_action(int iLookAhead);
	int find_reduce_action(int iLookAhead);
	void shift(int yyNewState, int yyMajor, YYMINORTYPE *yypMinor);
	void reduce(int yyruleno);
	void accept();
	
	void parse_failed();
	void syntax_error(int yymajor, YYMINORTYPE yyminor);

	int errCount;	// Shifts left before out of the error
	%nameARG_SDECL	// A place to hold %extra_argument
	yyStack stack;	// The parser's shift/reduce stack
	
	#ifndef NDEBUG
	static std::ostream* yyTraceStream;
	static string yyTracePrompt;
	static const string yyTokenName[];
	static const string yyRuleName[];
	#endif // NDEBUG
};
